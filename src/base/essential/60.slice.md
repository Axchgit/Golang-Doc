# 切片

在Go中，数组和切片两者看起来长得几乎一模一样，但功能有着不小的区别，数组是定长的数据结构，长度被指定后就不能被改变，而切片是不定长的，切片在容量不够时会自行扩容。



## 数组

如果事先就知道了要存放数据的长度，且后续使用中不会有扩容的需求，就可以考虑使用数组。

### 初始化

先来初始化一个长度为10的整型数组

```go
var nums [5]int
```

也可以用元素初始化

```go
nums := [5]int{1, 2, 3}
```

还可以通过`new`函数获得一个指针

```go
nums := new([5]int)
```

以上几种方式都会给`nums`分配一片固定大小的内存，区别只是最后一种得到的值是指针。

<br/>

在数组初始化时，需要注意的是，长度必须为一个常量表达式，否则将无法通过编译，常量表达式即表达式的最终结果是一个常量，错误例子如下：

```go
length := 5 // 这是一个变量
var nums [length]int
```

`length`是一个变量，因此无法用于初始化数组长度，如下是正确示例：

```go
const length = 5
var nums [length]int // 常量
var nums2 [length + 1]int // 常量表达式
var nums3 [(1 + 2 + 3) * 5]int // 常量表达式
var nums4 [5]int // 最常用的
```



### 使用

只要有数组名和下标，就可以访问数组中对应的元素。

```go
fmt.Println(nums[0])
```

同样的也可以修改数组元素

```go
nums[0] = 1
```

还可以通过内置函数`len`来访问数组元素的数量

```go
len(nums)
```

内置函数`cap`来访问数组容量，数组的容量等于数组长度，容量对于切片才有意义。

```go
cap(nums)
```



### 切割

切割数组的格式为`arr[startIndex:endIndex]`，切割的区间为**左闭右开**，例子如下：

```go
nums := [5]int{1, 2, 3, 4, 5}
nums[1:] // 子数组范围[1,5) ->1 2 3 4
nums[:5] // 子数组范围[0,5) -> 0 1 2 3 4
nums[2:3] // 子数组范围[2,3) -> 2
nums[1:3] // 子数组范围[1,3) -> 1 2
```



## 切片

切片在Go中应用的更加广泛一些，用于存放不知道长度的数据，且后续使用过程中可能会频繁的插入和删除元素。

### 初始化

切片的初始化方式有以下几种

```go
var nums []int // 值
nums := []int{1, 2, 3} // 值
nums := make([]int, 0, 0) // 值
nums := new([]int) // 指针
```

可以看到切片与数组在外貌上的区别，仅仅只是少了一个初始化长度。通常情况下，推荐使用`make`来创建一个空切片，只是对于切片而言，`make`函数接收三个参数：类型，长度，容量。举个例子解释一下长度与容量的区别，假设有一桶水，水并不是满的，桶的高度就是桶的容量，代表着总共能装多少高度的水，而桶中水的高度就是代表着长度，水的高度一定小于等于桶的高度，否则水就溢出来了。所以，切片的长度代表着切片中元素的个数，切片的容量代表着切片总共能装多少个元素，切片与数组最大的区别在于切片的容量会自动扩张，而数组不会。

::: tip

切片的底层实现依旧是数组

:::



### 使用

切片的基本使用与数组完全一致，区别只是切片可以动态变化长度，下面看几个例子。

切片可以通过`append`函数实现许多操作，函数签名如下，`slice`是要添加元素的目标切片，`elems`是待添加的元素，返回值是添加后的切片。

```go
func append(slice []Type, elems ...Type) []Type
```

首先创建一个长度为0，容量为0的空切片，然后在尾部插入一些元素，最后输出长度和容量。

```go
nums := make([]int, 0, 0)
nums = append(nums, 1, 2, 3, 4, 5, 6, 7)
fmt.Println(len(nums), cap(nums)) // 7 8 可以看到长度与容量并不一致。
```



### 删除元素

切片元素的删除需要结合`append`函数来使用，现有如下切片

```go
nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

从头部删除n个元素

```go
nums = nums[n:]
fmt.Println(nums) //n=3 [4 5 6 7 8 9 10]
```

从尾部删除n个元素

```go
nums = nums[:len(nums)-n]
fmt.Println(nums) //n=3 [1 2 3 4 5 6 7]
```

从中间指定下标i位置开始删除n个元素

```go
	nums = append(nums[:i], nums[i+n:]...)
fmt.Println(nums)// i=2，n=3，[1 2 6 7 8 9 10]
```

删除所有元素

```go
nums = nums[:0]
fmt.Println(nums) // []
```

### 插入元素

切片元素的插入也是需要结合`appned`函数来使用，现有切片如下，

```go
nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

从头部插入元素

```go
nums = append([]int{-1, 0}, nums...)
fmt.Println(nums) // [-1 0 1 2 3 4 5 6 7 8 9 10]
```

从中间下标i插入元素

```go
nums = append(nums[:i+1], append([]int{999, 999}, nums[i+1:]...)...)
fmt.Println(nums) // i=3，[1 2 3 4 999 999 5 6 7 8 9 10]
```

从尾部插入元素，就是`append`最原始的用法

```go
nums = append(nums, 99, 100)
fmt.Println(nums) // [1 2 3 4 5 6 7 8 9 10 99 100]
```



## 多维切片

先来看下面的一个例子，官方文档也有解释：[Effective Go - 二维切片](https://go.dev/doc/effective_go#two_dimensional_slices)

```go
var nums [5][5]int
for _, num := range nums {
   fmt.Println(num)
}
fmt.Println()
slices := make([][]int, 5)
for _, slice := range slices {
   fmt.Println(slice)
}
```

输出结果为

```
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]

[]
[]
[]
[]
[]
```

可以看到，同样是二维的数组和切片，其内部结构是不一样的。数组在初始化时，其一维和二维的长度早已固定，而切片的长度是不固定的，切片中的每一个切片长度都可能是不相同的，所以必须要单独初始化，切片初始化部分修改为如下代码即可。

```go
slices := make([][]int, 5)
for i := 0; i < len(slices); i++ {
   slices[i] = make([]int, 5)
}
```

最终输出结果为

```
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]

[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
[0 0 0 0 0]
```

